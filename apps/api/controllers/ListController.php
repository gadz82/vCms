<?php
/**
 * Created by PhpStorm.
 * User: Francesco
 * Date: 15/04/2019
 * Time: 12:25
 */
class ListController extends ApiController{
    protected static $defaulLimit = 30;

    protected static $defaultOrderBy = null;

    protected static $defaultPage = 1;

    protected static $defaultSearch = null;

    private $listFilters = [];

    public function initialize()
    {
        parent::initialize(); // TODO: Change the autogenerated stub
    }

    public function fetchAction(){
        $post_type = $this->dispatcher->getParam('post_type_slug');
        /* Tabella flat su cui effettuare la query */
        $tableName = '_'.$this->application.'_'.$post_type;

        $filter_params = $this->dispatcher->getParams();
        /* Rimuovo dai parametri che verranno utilizzati per l'elaborazioni di riordino e seo quelli che non mi servono */
        if(array_key_exists('post_type_slug', $filter_params)) unset($filter_params['post_type_slug']);
        if(array_key_exists('application', $filter_params)) unset($filter_params['application']);
        if(array_key_exists('id_application', $filter_params)) unset($filter_params['id_application']);

        if(!empty($filter_params) && count($filter_params) >= 1){

            $filter_params = $this->checkFilterParams(array_values($filter_params), $post_type);
            if(!$filter_params){
                throw new Exception('Wrong Params', 500);
            }
        } else {
            $filter_params = null;
        }

        $orderBy = isset($get_params['orderby']) ? $get_params['orderby'] : self::$defaultOrderBy;
        $limit = isset($get_params['limit']) ? $get_params['limit'] : self::$defaulLimit;
        $page = isset($get_params['page']) ? $get_params['page'] : self::$defaultPage;
        if(!$this->connection->tableExists($tableName)){
            throw new Exception('Post type not reachable', 500);
        } else {
            /**
             * Get lista post
             */
            $rs = $this->readList($post_type, $filter_params, $orderBy, $limit, $page);


            return $this->response->setJsonContent(
                [
                    'rs' => $rs['rs'],
                    'total_results' => $rs['nr_rs'],
                    'pages' => $rs['pages']
                ]
            );
        }
    }

    /**
     * @param $filters
     * @param $post_type
     * @param $application
     * @return array|bool|\Phalcon\Http\Response|\Phalcon\Http\ResponseInterface
     */
    private function checkFilterParams ($filters, $post_type, $application) {
        $nr = count($filters);
        $current_filters = [];
        $return_filters = [];
        $option = Options::findFirst([
            'conditions' => 'option_name = ?1',
            'bind' => [
                1 => 'columns_map_'.$application.'_'.$post_type.'_filter'
            ],
            'cache' => [
                "key" => "optionFilters".$post_type.$application,
                "lifetime" => 12400
            ]
        ]);

        if($option && !empty($option)){
            $flat_filters = json_decode($option->option_value, true);
        } else {
            return false;
        }
        for($i = 0; $i < $nr; $i++){
            if(strpos($filters[$i], '-') === -1) return false;

            list($filter_key, $filter_value) = explode('-', $filters[$i], 2);

            $pos = array_search($filter_key, $flat_filters);

            if($pos === false) return false;

            $current_filters[$pos] = $filters[$i];
            $filtro_valore = FiltriValori::findFirst([
                'conditions' => 'key = ?1',
                'bind' => [
                    1 => $filter_value
                ],
                'cache' => [
                    "key" => "checkFilterValueExistance" . $filter_key.$filter_value,
                    "lifetime" => 12400
                ]
            ]);

            if(!$filtro_valore) return false;
            $return_filters[$filter_key] = $filter_value;
            $this->listFilters[] = $filtro_valore;
        }

        //Controllo ordinamento array
        ksort($current_filters);
        if(array_values($current_filters) !== $filters){
            $this->response->redirect('/'.$post_type.'/list/'.implode('/', $current_filters), false, 301);
            return $this->response;
        }
        return $return_filters;
    }

    public function readList($post_type_slug, $filters = null, $orderBy = null, $limit = 10, $page = 1){

        $postTypeMetaFields = self::getPostTypeMetaFields($post_type_slug);
        $postTypeFilterFields = self::getPostTypeFilterFields($post_type_slug);
        $columns_select = [];
        $nr = count($postTypeMetaFields);

        $n = count($postTypeFilterFields);
        for($x = 0; $x < $n; $x++){
            $columns_select[] = "ef.".$postTypeFilterFields[$x]." AS filter_".$postTypeFilterFields[$x];
        }

        for($i = 0; $i < $nr; $i++){
            $columns_select[] = "em.".$postTypeMetaFields[$i]." AS meta_".$postTypeMetaFields[$i];
        }

        $query = "SELECT SQL_CALC_FOUND_ROWS
                  e.*,
                  ".implode(','.PHP_EOL, $columns_select)."
                FROM
                  `_".$this->application."_".$post_type_slug."` e
                INNER JOIN `_".$this->application."_".$post_type_slug."_meta` em ON em.id_post = e.id_post
                INNER JOIN `_".$this->application."_".$post_type_slug."_filter` ef ON ef.id_post = e.id_post
                WHERE
                    e.id_tipologia_stato = 1
                AND
                    e.attivo = 1 
                AND
                    e.data_inizio_pubblicazione < NOW()
            ";


        if(!is_null($filters)){
            foreach($filters as $column => $value){
                $query.= "
                        AND 
                            ef.key_".$column." = '{$value}'
                    ";
            }
        }

        if(is_null($orderBy)){
            $query.= "
                   ORDER BY e.data_inizio_pubblicazione DESC, e.id DESC
                ";

        } else {
            if($post_type_slug == 'auto'){
                switch($orderBy){
                    case 'titolo':
                        $query.= "
                           ORDER BY e.titolo ASC
                        ";
                        break;
                    case 'titolo-za':
                        $query.= "
                           ORDER BY e.titolo DESC
                        ";
                        break;
                    default:
                        $query.= "
                           ORDER BY e.data_inizio_pubblicazione DESC, e.id DESC
                        ";
                        break;
                }
            }
        }

        if(!is_null($limit)){
            $offset = ($page == 1) ? 0 : ($page-1)*$limit;
            $query.= " LIMIT ".$offset.", ".$limit;
        }

        $q = $this->connection->query($query);
        $q->setFetchMode(Phalcon\Db::FETCH_OBJ);
        $results = $q->fetchAll();

        if(!empty($results)){
            $nr = count($results);
            for($i = 0; $i < $nr; $i++){
                if(!is_null($results[$i]->meta_immagine)){
                    $results[$i]->file = Files::findFirst([
                        'conditions' => 'id = ?1',
                        'bind' => [1 => $results[$i]->meta_immagine],
                        'cache' => [
                            "key" => "listFindFile".$results[$i]->meta_immagine,
                            "lifetime" => 12400
                        ]
                    ]);

                }
                $results[$i]->readLink = $this->application == $this->config->application->defaultCode ?
                    DIRECTORY_SEPARATOR.$post_type_slug.DIRECTORY_SEPARATOR.$results[$i]->slug :
                    DIRECTORY_SEPARATOR.$this->application.DIRECTORY_SEPARATOR.$post_type_slug.DIRECTORY_SEPARATOR.$results[$i]->slug;
            }
        }

        $foundResults = $this->connection->query("SELECT FOUND_ROWS() as nr")->fetch();
        $pages = !is_null($limit) ? ceil($foundResults['nr']/$limit) : 1;
        return [
            'rs' => $results,
            'nr_rs' => $foundResults['nr'],
            'pages' => $pages
        ];

    }

    public function tagAction($slug){
        $post_type = $slug;
        $tableName = '_'.$post_type;

        $tag_params = $this->dispatcher->getParams();
        unset($tag_params[0]);
        if(!empty($tag_params) && isset($tag_params[1])){
            $tag = $tag_params[1];
            $tag = $this->checkTag($tag, $post_type);
            if(!$tag){
                throw new Exception('Wrong Params', 500);
            }
        } else {
            throw new Exception('Wrong Params', 500);
        }

        $get_params = $this->request->get();
        $orderBy = isset($get_params['orderby']) ? $get_params['orderby'] : self::$defaultOrderBy;
        $limit = isset($get_params['limit']) ? $get_params['limit'] : self::$defaulLimit;
        $page = isset($get_params['page']) ? $get_params['page'] : self::$defaultPage;

        if(!$this->connection->tableExists($tableName)){
            throw new Exception('Post type not reachable', 500);
        } else {
            /**
             * Get lista post
             */
            $rs = $this->readTagList($post_type, $tag->tag, $orderBy, $limit, $page);

            return $this->response->setJsonContent(
                [
                    'rs' => $rs['rs'],
                    'total_results' => $rs['nr_rs'],
                    'pages' => $rs['pages']
                ]
            );
        }
    }

    /**
     * @param $tag
     * @param $post_type
     * @return bool|\Phalcon\Mvc\Model\ResultsetInterface
     */
    private function checkTag($tag, $post_type){

        $tag = Tags::query()
            ->innerJoin('PostsTags', 'pt.id_tag = Tags.id AND pt.attivo = 1', 'pt')
            ->innerJoin('Posts', 'p.id = pt.id_post AND p.id_tipologia_stato = 1 AND p.attivo = 1','p')
            ->innerJoin('TipologiePost', 'tp.id = p.id_tipologia_post AND tp.attivo = 1 AND tp.slug = ?2', 'tp')
            ->where('Tags.tag = ?1 AND Tags.attivo = 1')
            ->bind([
                1 => $tag,
                2 => $post_type
            ])
            ->cache([
                "key" => "checkTag".$tag.$post_type,
                "lifetime" => 12400
            ])
            ->execute()->getFirst();
        if(!$tag) return false;
        return $tag;
    }

    private function readTagList($post_type_slug, $tag, $orderBy = null, $limit = 10, $page = 1){

        $postTypeMetaFields = self::getPostTypeMetaFields($post_type_slug);
        $postTypeFilterFields = self::getPostTypeFilterFields($post_type_slug);
        $columns_select = [];

        $nr = count($postTypeMetaFields);
        $n = count($postTypeFilterFields);

        for($x = 0; $x < $n; $x++){
            $columns_select[] = "ef.".$postTypeFilterFields[$x]." AS filter_".$postTypeFilterFields[$x];
        }

        for($i = 0; $i < $nr; $i++){
            $columns_select[] = "em.".$postTypeMetaFields[$i]." AS meta_".$postTypeMetaFields[$i];
        }

        $query = "SELECT SQL_CALC_FOUND_ROWS
                  e.*,
                  f.*,
                  ".implode(','.PHP_EOL, $columns_select)."
                FROM
                  _".$post_type_slug." e
                INNER JOIN  _".$post_type_slug."_meta em ON em.id_post = e.id_post
                INNER JOIN  _".$post_type_slug."_filter ef ON ef.id_post = e.id_post
                INNER JOIN files f ON f.id = em.immagine AND f.attivo = 1
                INNER JOIN posts_tags pt ON pt.id_post = e.id_post AND pt.attivo = 1
                INNER JOIN tags t ON t.id = pt.id_tag AND t.attivo = 1
                WHERE
                    t.tag = '{$tag}'
                AND
                    e.id_tipologia_stato = 1
                AND
                    e.data_inizio_pubblicazione < NOW()
            ";


        if(is_null($orderBy)){
            $query.= "
               ORDER BY e.data_inizio_pubblicazione DESC, e.id DESC
            ";

        } else {
            if($post_type_slug == 'auto'){
                switch($orderBy){
                    case 'titolo':
                        $query.= "
                           ORDER BY e.titolo ASC
                        ";
                        break;
                    case 'titolo-za':
                        $query.= "
                           ORDER BY e.titolo DESC
                        ";
                        break;
                    default:
                        $query.= "
                           ORDER BY e.data_inizio_pubblicazione DESC, e.id DESC
                        ";
                        break;
                }
            }
        }

        if(!is_null($limit)){
            $offset = ($page == 1) ? 0 : ($page-1)*$limit;
            $query.= " LIMIT ".$offset.", ".$limit;
        }

        $q = $this->connection->query($query);
        $q->setFetchMode(Phalcon\Db::FETCH_OBJ);
        $results = $q->fetchAll();
        $foundResults = $this->connection->query("SELECT FOUND_ROWS() as nr")->fetch();
        $pages = !is_null($limit) ? ceil($foundResults['nr']/$limit) : 1;

        return [
            'rs' => $results,
            'nr_rs' => $foundResults['nr'],
            'pages' => $pages
        ];
    }

}